# Simple Produce App

## Project Overview
- **Name:** Simple Produce App
- **Description:** A small JavaFX desktop application that tracks farmers' produce. It stores produce items (name, kilograms, price per kg) in an embedded H2 database and displays them in a table with a calculated total price.

## Files
- **Source:** `Produce.java`, `SimpleProduceApp.java`
- **Scripts:** `scripts/run-simple.ps1` (PowerShell helper to compile and run)
- **Tools folder:** `tools/javafx` (JavaFX SDK) and `tools/h2` (H2 JDBC jar expected)
- **Database:** `data/` (H2 database files are created here when the app runs)

## Requirements
- **Java:** JDK 17+ (JavaFX 21 was used when this project was created; newer JDKs may work.)
- **JavaFX SDK:** `tools/javafx/javafx-sdk-21.0.5` (or a similarly named folder under `tools/javafx`)
- **H2 JDBC Jar:** Place H2 jar under `tools/h2` (the run script expects `tools/h2/h2-2.2.224.jar`).
- **PowerShell:** For running `scripts/run-simple.ps1` on Windows (PowerShell 5.1 or later).

## Quick Walkthrough
- **Produce.java**: Plain Java class (POJO) representing a produce item. Fields: `id`, `name`, `kg`, `price`. Includes getters/setters and `getTotal()` which returns `kg * price`.
- **SimpleProduceApp.java**: A JavaFX Application that:
  - Ensures the database schema exists (`ensureSchema()`)
  - Loads rows from the produce table (`loadData()`)
  - Shows a table with columns: Produce, Kg, Price, Total
  - Has a hidden form to add new produce items which are inserted into the H2 database (`insertProduce()`)

## Build & Run (recommended - PowerShell script)
The repository includes `scripts/run-simple.ps1` which compiles and runs the app using the JavaFX SDK found under `tools/javafx` and the H2 jar under `tools/h2`.

Open PowerShell, change to the project directory (one level containing `Produce.java`), and run:

```powershell
cd "c:\Users\soahf\Desktop\JAVs\Java" # Adjust this path if your project is elsewhere
./scripts/run-simple.ps1
```

This script will:
- Locate the JavaFX SDK directory under `tools/javafx` (it looks for `javafx-sdk-*`).
- Expect the H2 jar at `tools/h2/h2-2.2.224.jar` (edit the script or place the jar accordingly).
- Compile sources to `out/` and run the application.

## Manual Build & Run (commands)
If you prefer to run the commands manually, use these (PowerShell / Windows):

### 1) Compile
```powershell
javac --module-path "tools\javafx\javafx-sdk-21.0.5\lib" --add-modules javafx.controls,javafx.fxml -cp "tools\h2\h2-2.2.224.jar" -d out Produce.java SimpleProduceApp.java
```

### 2) Run
```powershell
java --module-path "tools\javafx\javafx-sdk-21.0.5\lib" --add-modules javafx.controls,javafx.fxml -cp "out;tools\h2\h2-2.2.224.jar" SimpleProduceApp
```

Adjust paths if your JavaFX SDK folder name or H2 jar filename differ.

## Database Details
- The app uses an embedded H2 database URL: `jdbc:h2:./data/produce_db;AUTO_SERVER=TRUE`.
- Database files will be created under `data/` (e.g., `data/produce_db.mv.db`).
- To reset the database, stop the application and delete the files inside `data/` (or use an H2 console if you add one).

## Troubleshooting
- **Error: JavaFX runtime components are missing**
  - Cause: JavaFX not on the module path or wrong `--module-path` used.
  - Fix: Ensure the JavaFX SDK is unpacked under `tools/javafx/javafx-sdk-*` and use the `--module-path` flag shown above.

- **Error: ClassNotFoundException or NoClassDefFoundError for H2**
  - Cause: H2 jar not on the classpath.
  - Fix: Place the H2 jar in `tools/h2` and ensure the `-cp` includes `tools\h2\h2-2.2.224.jar`.

- **SQL exceptions on startup**
  - The app will try to create a table on first run. If you see permission or disk errors, verify you have write permission to the project folder and `data/`.

- **If `scripts/run-simple.ps1` fails**
  - The script checks for the JavaFX SDK and the H2 jar; read the error message in PowerShell — it will tell you which file is missing and the expected path.

## Extending the App
- Add edit/delete actions to the UI and corresponding SQL operations.
- Add input validation or improved number formatting for price and kg.
- Add an export feature (CSV) for the table contents.

## Detailed Code Explanation

### Produce.java - The Data Model

This file defines the `Produce` class, which represents a single produce item (e.g., apples, tomatoes). It follows the *POJO* (Plain Old Java Object) pattern and is used to store and transfer data between the database and the UI.

#### Fields
```java
private long id;
private String name;
private double kg;
private double price;
```
- **id**: A unique identifier for each produce item (auto-generated by the database).
- **name**: The name of the produce (e.g., "Tomatoes").
- **kg**: The quantity in kilograms.
- **price**: The price per kilogram.

#### Constructor
```java
public Produce(long id, String name, double kg, double price) {
    this.id = id;
    this.name = name;
    this.kg = kg;
    this.price = price;
}
```
- Initializes a new `Produce` object with all four parameters.
- This constructor is called when creating objects from database rows or when adding new produce.

#### Getters and Setters
```java
public long getId() { return id; }
public void setId(long id) { this.id = id; }

public String getName() { return name; }
public void setName(String name) { this.name = name; }

public double getKg() { return kg; }
public void setKg(double kg) { this.kg = kg; }

public double getPrice() { return price; }
public void setPrice(double price) { this.price = price; }
```
- *Getters* retrieve field values (used by JavaFX table to display data).
- *Setters* modify field values (used by the application to update produce info).

#### The `getTotal()` Method
```java
public double getTotal() { return kg * price; }
```
- Calculates the total price by multiplying quantity (kg) by unit price.
- This is a *computed field* — not stored in the database, but calculated on demand for display in the table.

---

### SimpleProduceApp.java - The Main Application

This file extends JavaFX's `Application` class and builds the entire desktop UI. It manages the window, table display, form input, and all database interactions.

#### Class Variables (Static Database Info)
```java
private static final String JDBC_URL = "jdbc:h2:./data/produce_db;AUTO_SERVER=TRUE";
private static final String JDBC_USER = "sa";
private static final String JDBC_PASS = "";

private TableView<Produce> table;
private ObservableList<Produce> data;
private GridPane form;
```
- **JDBC_URL**: Connection string for the H2 embedded database.
  - `./data/produce_db` is the database file location (files stored in `data/` folder).
  - `AUTO_SERVER=TRUE` allows multiple connections to the same database.
- **JDBC_USER / JDBC_PASS**: Login credentials (H2 defaults: user `sa`, empty password).
- **table**: JavaFX widget that displays the produce list.
- **data**: An `ObservableList` — a list that automatically updates the table when items are added/removed.
- **form**: The input form (hidden until "Dashboard" button is clicked).

#### The `start()` Method
This is the entry point for any JavaFX application. It builds the entire UI.

##### 1. Ensure Database Schema
```java
ensureSchema();
```
- Calls the `ensureSchema()` method to create the `produce` table if it doesn't already exist.

##### 2. Build the Root Layout (BorderPane)
```java
BorderPane root = new BorderPane();
```
- `BorderPane` is a container that divides the window into five regions: top, bottom, left, right, and center.

##### 3. Top Section - Header
```java
Button dashboardBtn = new Button("Dashboard");
HBox top = new HBox(10, new Label("Farmers Produce Tracker"), dashboardBtn);
top.setPadding(new Insets(10));
root.setTop(top);
```
- Creates a *header bar* with the title "Farmers Produce Tracker" and a "Dashboard" button.
- `HBox` arranges items horizontally with 10 pixels spacing.
- This header is placed at the top of the window.

##### 4. Center Section - Table Setup
```java
table = new TableView<>();
```
- Creates an empty table widget.

*Table Columns:*
```java
TableColumn<Produce, String> nameCol = new TableColumn<>("Produce");
nameCol.setCellValueFactory(new PropertyValueFactory<>("name"));

TableColumn<Produce, Number> kgCol = new TableColumn<>("Kg");
kgCol.setCellValueFactory(c -> new SimpleDoubleProperty(c.getValue().getKg()));

TableColumn<Produce, Number> priceCol = new TableColumn<>("Price");
priceCol.setCellValueFactory(c -> new SimpleDoubleProperty(c.getValue().getPrice()));

TableColumn<Produce, Number> totalCol = new TableColumn<>("Total");
totalCol.setCellValueFactory(c -> new SimpleDoubleProperty(c.getValue().getTotal()));
```
- *Four columns* are created:
  - *"Produce"*: Shows the `name` field using `PropertyValueFactory`.
  - *"Kg"*: Shows the `kg` field (wrapped in `SimpleDoubleProperty` for number formatting).
  - *"Price"*: Shows the `price` field.
  - *"Total"*: Shows the calculated total (calls `getTotal()` for each row).
- The `setCellValueFactory()` tells JavaFX how to extract data from each `Produce` object and display it in the column.

```java
table.getColumns().add(nameCol);
table.getColumns().add(kgCol);
table.getColumns().add(priceCol);
table.getColumns().add(totalCol);
table.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY_FLEX_LAST_COLUMN);
```
- Adds all columns to the table.
- `CONSTRAINED_RESIZE_POLICY_FLEX_LAST_COLUMN` makes the table fill the window width, with the last column (Total) stretching to fit.

```java
data = FXCollections.observableArrayList();
table.setItems(data);
root.setCenter(table);
```
- Creates an `ObservableList` to hold produce items.
- Links it to the table so any changes to `data` are reflected in the UI.
- Places the table in the center of the window.

##### 5. Bottom Section - Input Form
```java
form = new GridPane();
form.setPadding(new Insets(12));
form.setHgap(10);
form.setVgap(8);
```
- Creates a `GridPane` (a grid layout) with padding and gaps between cells.

*Form Input Fields:*
```java
TextField nameField = new TextField();
TextField kgField = new TextField();
TextField priceField = new TextField();
Button addBtn = new Button("Add");

form.addRow(0, new Label("Produce:"), nameField);
form.addRow(1, new Label("Kg:"), kgField);
form.addRow(2, new Label("Price:"), priceField);
form.add(addBtn, 1, 3);
```
- Three `TextField` widgets for user input (produce name, kg, price).
- Labels describe each field.
- Organized in a grid with 2 columns (label, input field).
- The "Add" button is placed at row 3, column 1.

*Add Button Action:*
```java
addBtn.setOnAction(e -> {
    String name = nameField.getText().trim();
    if (name.isEmpty()) {
        showAlert(Alert.AlertType.WARNING, "Validation", "Produce name is required");
        return;
    }
    double kg;
    double price;
    try {
        kg = Double.parseDouble(kgField.getText().trim());
        price = Double.parseDouble(priceField.getText().trim());
    } catch (NumberFormatException ex) {
        showAlert(Alert.AlertType.WARNING, "Validation", "Kg and Price must be numbers");
        return;
    }
    try {
        long id = insertProduce(name, kg, price);
        data.add(new Produce(id, name, kg, price));
        nameField.clear();
        kgField.clear();
        priceField.clear();
    } catch (Exception ex) {
        showAlert(Alert.AlertType.ERROR, "DB Error", ex.getMessage());
    }
});
```
- When clicked, the button:
  1. *Validates* the produce name is not empty.
  2. *Parses* kg and price as numbers (shows error if they're not).
  3. *Inserts* the produce into the database via `insertProduce()`.
  4. *Adds* a new `Produce` object to the `data` list (which updates the table).
  5. *Clears* all input fields for the next entry.
  6. Shows error alerts if anything fails.

*Toggle Form Visibility:*
```java
form.setVisible(false);
form.setManaged(false);
dashboardBtn.setOnAction(e -> {
    boolean showing = form.isVisible();
    form.setVisible(!showing);
    form.setManaged(!showing);
    if (!showing) {
        table.requestFocus();
    }
});

root.setBottom(form);
```
- The form is *hidden by default* (`setVisible(false)` and `setManaged(false)`).
- When the "Dashboard" button is clicked, it *toggles* the form visibility.
- `setManaged(false)` prevents the hidden form from taking up space in the layout.

##### 6. Load Existing Data and Display Window
```java
loadData();

Scene scene = new Scene(root, 800, 500);
stage.setTitle("Produce Dashboard");
stage.setScene(scene);
stage.show();
```
- Loads all produce from the database into the table.
- Creates a `Scene` (800x500 pixels) with the root layout.
- Sets the window title and displays it.

---

#### Helper Methods

##### `loadData()`
```java
private void loadData() {
    data.clear();
    try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASS);
         PreparedStatement ps = conn.prepareStatement("SELECT id, name, kg, price FROM produce ORDER BY id")) {
        try (ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                data.add(new Produce(
                        rs.getLong("id"),
                        rs.getString("name"),
                        rs.getDouble("kg"),
                        rs.getDouble("price")
                ));
            }
        }
    } catch (SQLException e) {
        showAlert(Alert.AlertType.ERROR, "DB Error", e.getMessage());
    }
}
```
- *Clears* the `data` list.
- *Connects* to the database and runs a SQL `SELECT` query to retrieve all produce.
- *Iterates* through the result set and creates `Produce` objects for each row.
- *Adds* each object to the `data` list (triggering a table update).
- *Catches* any SQL errors and shows an alert.
- Uses *try-with-resources* (`try (Connection conn = ...)`) to automatically close the connection and statement.

##### `ensureSchema()`
```java
private void ensureSchema() throws SQLException {
    try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASS);
         Statement st = conn.createStatement()) {
        st.executeUpdate(
                "CREATE TABLE IF NOT EXISTS produce (" +
                        "id IDENTITY PRIMARY KEY, " +
                        "name VARCHAR(255) NOT NULL, " +
                        "kg DOUBLE NOT NULL, " +
                        "price DOUBLE NOT NULL, " +
                        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)"
        );
    }
}
```
- *Creates* the `produce` table if it doesn't exist.
- *Table structure:*
  - `id`: Auto-incrementing primary key.
  - `name`: Text field (up to 255 characters), required.
  - `kg`: Double-precision number, required.
  - `price`: Double-precision number, required.
  - `created_at`: Timestamp (defaults to current time when a row is inserted).
- `CREATE TABLE IF NOT EXISTS` ensures the command doesn't fail if the table already exists.

##### `insertProduce()`
```java
private long insertProduce(String name, double kg, double price) throws SQLException {
    try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASS);
         PreparedStatement ps = conn.prepareStatement(
                 "INSERT INTO produce(name, kg, price) VALUES(?,?,?)",
                 Statement.RETURN_GENERATED_KEYS)) {
        ps.setString(1, name);
        ps.setDouble(2, kg);
        ps.setDouble(3, price);
        ps.executeUpdate();
        try (ResultSet keys = ps.getGeneratedKeys()) {
            if (keys.next()) return keys.getLong(1);
        }
    }
    return -1L;
}
```
- *Inserts* a new produce row into the database.
- Uses *parameterized queries* (`?` placeholders) to safely insert user input.
- `ps.setString(1, name)`, `ps.setDouble(2, kg)`, etc. bind the values.
- `Statement.RETURN_GENERATED_KEYS` tells the database to return the auto-generated `id`.
- *Retrieves* the generated `id` from the result set and returns it.
- Returns `-1L` if something fails (the `addBtn` action catches this).

##### `showAlert()`
```java
private void showAlert(Alert.AlertType type, String title, String msg) {
    Alert alert = new Alert(type);
    alert.setTitle(title);
    alert.setHeaderText(null);
    alert.setContentText(msg);
    alert.showAndWait();
}
```
- A utility method to display popup alert dialogs.
- Parameters: alert type (`WARNING`, `ERROR`, etc.), title, and message.
- `showAndWait()` blocks execution until the user closes the alert.

##### `main()`
```java
public static void main(String[] args) {
    launch(args);
}
```
- Entry point for the Java program.
- `launch(args)` is a JavaFX method that initializes the framework and calls `start()`.

---

*Notes for Developers*
- The table uses `PropertyValueFactory` and simple property wrappers to bridge POJOs to JavaFX columns.
- The database operations are simple JDBC with try-with-resources; this keeps connections local and short-lived.

*License & Attribution*
- This README does not add a license. If you have a preferred license, add a `LICENSE` file to the repository.
